-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Auction in hydra head
--   
--   Auction in hydra head
@package hydra-auction
@version 0.1.0

module HydraAuctionUtils.Extras.CardanoApi
networkIdToNetwork :: NetworkId -> Network

module HydraAuctionUtils.Plutus
byAddress :: Address -> [TxOut] -> [TxOut]
decodeOutputDatum :: FromData a => TxInfo -> TxOut -> Maybe a
isNotAdaOnlyOutput :: TxOut -> Bool
lovelaceOfOutput :: TxOut -> Integer
nothingForged :: TxInfo -> Bool
strictTo :: a -> Interval a
rightExclusiveInterval :: a -> a -> Interval a
extendIntervalRight :: Interval a -> Interval a


-- | Prelude for off-chain modules.
--   
--   Includes imports not giving any name-collisions for:
--   
--   <ul>
--   <li>Basic containers types and utilities</li>
--   <li>Our MTL-like stack</li>
--   </ul>
module HydraAuctionUtils.Prelude

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: forall (r :: RuntimeRep) a (b :: TYPE r). a -> b -> b
infixr 0 `seq`

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `mod`
infixl 7 `div`
infixl 7 `rem`
infixl 7 `quot`

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor (f :: Type -> Type)

-- | Using <tt>ApplicativeDo</tt>: '<tt><a>fmap</a> f as</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do a &lt;- as
--      pure (f a)
--   </pre>
--   
--   with an inferred <tt>Functor</tt> constraint.
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt>a <a>&lt;$</a> bs</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do bs
--      pure a
--   </pre>
--   
--   with an inferred <tt>Functor</tt> constraint.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 -
infixl 6 +
infixl 7 *

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 <
infix 4 <=
infix 4 >
infix 4 >=

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a

-- | attempts to parse a value from the front of the string, returning a
--   list of (parsed value, remaining string) pairs. If there is no
--   successful parse, the returned list is empty.
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
readsPrec :: Read a => Int -> ReadS a

-- | The method <a>readList</a> is provided to allow the programmer to give
--   a specialised way of parsing lists of values. For example, this is
--   used by the predefined <a>Read</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be are expected to use
--   double quotes, rather than square brackets.
readList :: Read a => ReadS [a]
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt>fs <a>&lt;*&gt;</a> as</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do f &lt;- fs
--      a &lt;- as
--      pure (f a)
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Sequence actions, discarding the value of the first argument.
--   
--   '<tt>as <a>*&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
--   
--   This is a tad complicated for our <tt>ApplicativeDo</tt> extension
--   which will give it a <tt>Monad</tt> constraint. For an
--   <tt>Applicative</tt> constraint we write it of the form
--   
--   <pre>
--   do _ &lt;- as
--      b &lt;- bs
--      pure b
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt>as <a>&lt;*</a> bs</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do a &lt;- as
--      bs
--      pure a
--   </pre>
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*
infixl 4 *>
infixl 4 <*>

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: Type -> Type)

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl'</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl'</a> instead of <a>foldl</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>z `f` x1</tt>
--   in the above example) before applying them to the operator (e.g. to
--   <tt>(`f` x2)</tt>). This results in a thunk chain &lt;math&gt;
--   elements long, which then must be evaluated from the outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>traverse</a> f = <a>traverse</a> (t .
--   f)</tt> for every applicative transformation <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>traverse</a> <a>Identity</a> =
--   <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>traverse</a> (<a>Compose</a> .
--   <a>fmap</a> g . f) = <a>Compose</a> . <a>fmap</a> (<a>traverse</a> g)
--   . <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>sequenceA</a> = <a>sequenceA</a> .
--   <a>fmap</a> t</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>sequenceA</a> . <a>fmap</a> <a>Identity</a>
--   = <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>sequenceA</a> . <a>fmap</a>
--   <a>Compose</a> = <a>Compose</a> . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <a>Compose</a> are from <a>Data.Functor.Identity</a> and
--   <a>Data.Functor.Compose</a>.
--   
--   A result of the naturality law is a purity law for <a>traverse</a>
--   
--   <pre>
--   <a>traverse</a> <a>pure</a> = <a>pure</a>
--   </pre>
--   
--   (The naturality law is implied by parametricity and thus so is the
--   purity law [1, p15].)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
--   
--   References: [1] The Essence of the Iterator Pattern, Jeremy Gibbons
--   and Bruno C. d. S. Oliveira
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data Char

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   For more information about this type's representation, see the
--   comments in its implementation.
data Integer

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data IO a

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The kind of types with lifted values. For example <tt>Int ::
--   Type</tt>.
type Type = Type

-- | The kind of constraints, like <tt>Show a</tt>
data Constraint

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
--   
--   See <a>Data.List</a> for operations on lists.
type String = [Char]

-- | The <a>read</a> function reads input from a string, which must be
--   completely consumed by the input process. <a>read</a> fails with an
--   <a>error</a> if the parse is unsuccessful, and it is therefore
--   discouraged from being used in real applications. Use <a>readMaybe</a>
--   or <a>readEither</a> for safe alternatives.
--   
--   <pre>
--   &gt;&gt;&gt; read "123" :: Int
--   123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; read "hello" :: Int
--   *** Exception: Prelude.read: no parse
--   </pre>
read :: Read a => String -> a

-- | The class of contravariant functors.
--   
--   Whereas in Haskell, one can think of a <a>Functor</a> as containing or
--   producing values, a contravariant functor is a functor that can be
--   thought of as <i>consuming</i> values.
--   
--   As an example, consider the type of predicate functions <tt>a -&gt;
--   Bool</tt>. One such predicate might be <tt>negative x = x &lt; 0</tt>,
--   which classifies integers as to whether they are negative. However,
--   given this predicate, we can re-use it in other situations, providing
--   we have a way to map values <i>to</i> integers. For instance, we can
--   use the <tt>negative</tt> predicate on a person's bank balance to work
--   out if they are currently overdrawn:
--   
--   <pre>
--   newtype Predicate a = Predicate { getPredicate :: a -&gt; Bool }
--   
--   instance Contravariant Predicate where
--     contramap f (Predicate p) = Predicate (p . f)
--                                            |   `- First, map the input...
--                                            `----- then apply the predicate.
--   
--   overdrawn :: Predicate Person
--   overdrawn = contramap personBankBalance negative
--   </pre>
--   
--   Any instance should be subject to the following laws:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>contramap</a> <a>id</a> =
--   <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>contramap</a> (g . f) = <a>contramap</a>
--   f . <a>contramap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type of
--   <a>contramap</a> and the first law, so you need only check that the
--   former condition holds.
class Contravariant (f :: Type -> Type)
contramap :: Contravariant f => (a -> b) -> f b -> f a

-- | Replace all locations in the output with the same value. The default
--   definition is <tt><a>contramap</a> . <a>const</a></tt>, but this may
--   be overridden with a more efficient version.
(>$) :: Contravariant f => b -> f b -> f a
infixl 4 >$

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | Repeat an action indefinitely.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt><a>forever</a> as</tt>' can be
--   understood as the pseudo-<tt>do</tt> expression
--   
--   <pre>
--   do as
--      as
--      ..
--   </pre>
--   
--   with <tt>as</tt> repeating.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
forever :: Applicative f => f a -> f b

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | The <a>readIO</a> function is similar to <a>read</a> except that it
--   signals parse failure to the <a>IO</a> monad instead of terminating
--   the program.
readIO :: Read a => String -> IO a

-- | The <a>readLn</a> function combines <a>getLine</a> and <a>readIO</a>.
readLn :: Read a => IO a

-- | The computation <a>appendFile</a> <tt>file str</tt> function appends
--   the string <tt>str</tt>, to the file <tt>file</tt>.
--   
--   Note that <a>writeFile</a> and <a>appendFile</a> write a literal
--   string to a file. To write a value of any printable type, as with
--   <a>print</a>, use the <a>show</a> function to convert the value to a
--   string first.
--   
--   <pre>
--   main = appendFile "squares" (show [(x,x*x) | x &lt;- [0,0.1..2]])
--   </pre>
appendFile :: FilePath -> String -> IO ()

-- | The computation <a>writeFile</a> <tt>file str</tt> function writes the
--   string <tt>str</tt>, to the file <tt>file</tt>.
writeFile :: FilePath -> String -> IO ()

-- | The <a>readFile</a> function reads a file and returns the contents of
--   the file as a string. The file is read lazily, on demand, as with
--   <a>getContents</a>.
readFile :: FilePath -> IO String

-- | The <a>interact</a> function takes a function of type
--   <tt>String-&gt;String</tt> as its argument. The entire input from the
--   standard input device is passed to this function as its argument, and
--   the resulting string is output on the standard output device.
interact :: (String -> String) -> IO ()

-- | The <a>getContents</a> operation returns all user input as a single
--   string, which is read lazily as it is needed (same as
--   <a>hGetContents</a> <a>stdin</a>).
getContents :: IO String

-- | Read a line from the standard input device (same as <a>hGetLine</a>
--   <a>stdin</a>).
getLine :: IO String

-- | Read a character from the standard input device (same as
--   <a>hGetChar</a> <a>stdin</a>).
getChar :: IO Char

-- | The same as <a>putStr</a>, but adds a newline character.
putStrLn :: String -> IO ()

-- | Write a string to the standard output device (same as <a>hPutStr</a>
--   <a>stdout</a>).
putStr :: String -> IO ()

-- | Write a character to the standard output device (same as
--   <a>hPutChar</a> <a>stdout</a>).
putChar :: Char -> IO ()

-- | Suspends the current thread for a given number of microseconds (GHC
--   only).
--   
--   There is no guarantee that the thread will be rescheduled promptly
--   when the delay has expired, but the thread will never continue to run
--   <i>earlier</i> than specified.
threadDelay :: Int -> IO ()

-- | Raise an <a>IOError</a> in the <a>IO</a> monad.
ioError :: IOError -> IO a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Construct an <a>IOError</a> value with a string describing the error.
--   The <tt>fail</tt> method of the <a>IO</a> instance of the <a>Monad</a>
--   class raises a <a>userError</a>, thus:
--   
--   <pre>
--   instance Monad IO where
--     ...
--     fail s = ioError (userError s)
--   </pre>
userError :: String -> IOError

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   As of base 4.8.0.0, <a>forM_</a> is just <a>for_</a>, specialized to
--   <a>Monad</a>.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | The <a>lex</a> function reads a single lexeme from the input,
--   discarding initial white space, and returning the characters that
--   constitute the lexeme. If the input string contains only white space,
--   <a>lex</a> returns a single successful `lexeme' consisting of the
--   empty string. (Thus <tt><a>lex</a> "" = [("","")]</tt>.) If there is
--   no legal lexeme at the beginning of the input string, <a>lex</a> fails
--   (i.e. returns <tt>[]</tt>).
--   
--   This lexer is not completely faithful to the Haskell lexical syntax in
--   the following respects:
--   
--   <ul>
--   <li>Qualified names are not handled properly</li>
--   <li>Octal and hexadecimal numerics are not recognized as a single
--   token</li>
--   <li>Comments are not treated properly</li>
--   </ul>
lex :: ReadS String

-- | <tt><a>readParen</a> <a>True</a> p</tt> parses what <tt>p</tt> parses,
--   but surrounded with parentheses.
--   
--   <tt><a>readParen</a> <a>False</a> p</tt> parses what <tt>p</tt>
--   parses, but optionally surrounded with parentheses.
readParen :: Bool -> ReadS a -> ReadS a

-- | A parser for a type <tt>a</tt>, represented as a function that takes a
--   <a>String</a> and returns a list of possible parses as
--   <tt>(a,<a>String</a>)</tt> pairs.
--   
--   Note that this kind of backtracking parser is very inefficient;
--   reading a large structure may be quite slow (cf <a>ReadP</a>).
type ReadS a = String -> [(a, String)]

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^
odd :: Integral a => a -> Bool
even :: Integral a => a -> Bool

-- | utility function that surrounds the inner show function with
--   parentheses when the <a>Bool</a> parameter is <a>True</a>.
showParen :: Bool -> ShowS -> ShowS

-- | utility function converting a <a>String</a> to a show function that
--   simply prepends the string unchanged.
showString :: String -> ShowS

-- | utility function converting a <a>Char</a> to a show function that
--   simply prepends the character unchanged.
showChar :: Char -> ShowS

-- | equivalent to <a>showsPrec</a> with a precedence of 0.
shows :: Show a => a -> ShowS

-- | The <tt>shows</tt> functions return a function that prepends the
--   output <a>String</a> to an existing <a>String</a>. This allows
--   constant-time concatenation of results using function composition.
type ShowS = String -> String

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>. It is capable of
--   list fusion, but it is restricted to its first list argument and its
--   resulting list.
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function. For example, <tt><a>zipWith</a> (+)</tt> is applied to two
--   lists to produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | &lt;math&gt;. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: [a] -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
iterate :: (a -> a) -> a -> [a]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
init :: [a] -> [a]

-- | &lt;math&gt;. Extract the last element of a list, which must be finite
--   and non-empty.
last :: [a] -> a

-- | &lt;math&gt;. Extract the elements after the head of a list, which
--   must be non-empty.
tail :: [a] -> [a]

-- | &lt;math&gt;. Extract the first element of a list, which must be
--   non-empty.
head :: [a] -> a

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: HasCallStack => Maybe a -> a

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt><a>void</a> as</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do as
--      pure ()
--   </pre>
--   
--   with an inferred <tt>Functor</tt> constraint.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | Put a value into an <a>MVar</a>. If the <a>MVar</a> is currently full,
--   <a>putMVar</a> will wait until it becomes empty.
--   
--   There are two further important properties of <a>putMVar</a>:
--   
--   <ul>
--   <li><a>putMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>putMVar</a>, and the <a>MVar</a> becomes empty,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>putMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
putMVar :: MVar a -> a -> IO ()

-- | Return the contents of the <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>takeMVar</a> will wait until it is full. After a
--   <a>takeMVar</a>, the <a>MVar</a> is left empty.
--   
--   There are two further important properties of <a>takeMVar</a>:
--   
--   <ul>
--   <li><a>takeMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>takeMVar</a>, and the <a>MVar</a> becomes full,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>takeMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
takeMVar :: MVar a -> IO a

-- | Create an <a>MVar</a> which contains the supplied value.
newMVar :: a -> IO (MVar a)

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data MVar a

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a

-- | A variant of <a>error</a> that does not produce a stack trace.
errorWithoutStackTrace :: forall (r :: RuntimeRep) (a :: TYPE r). [Char] -> a

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => [Char] -> a

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT s (m :: Type -> Type) a
StateT :: (s -> m (a, s)) -> StateT s (m :: Type -> Type) a
[runStateT] :: StateT s (m :: Type -> Type) a -> s -> m (a, s)

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
newtype ReaderT r (m :: Type -> Type) a
ReaderT :: (r -> m a) -> ReaderT r (m :: Type -> Type) a
[runReaderT] :: ReaderT r (m :: Type -> Type) a -> r -> m a

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: Type -> Type) | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r (m :: Type -> Type) | m -> r

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Executes a computation in a modified environment.
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | Retrieves a function of the current environment.
reader :: MonadReader r m => (r -> a) -> m a

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data Map k a

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Similar to <a>catch</a>, but returns an <a>Either</a> result. See
--   <a>Control.Exception</a>'s <a>try</a>.
try :: (MonadCatch m, Exception e) => m a -> m (Either e a)

-- | A class for monads in which exceptions may be thrown.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   throwM e &gt;&gt; x = throwM e
--   </pre>
--   
--   In other words, throwing an exception short-circuits the rest of the
--   monadic computation.
class Monad m => MonadThrow (m :: Type -> Type)

-- | Throw an exception. Note that this throws when this action is run in
--   the monad <tt>m</tt>, not when it is applied. It is a generalization
--   of <a>Control.Exception</a>'s <a>throwIO</a>.
--   
--   Should satisfy the law:
--   
--   <pre>
--   throwM e &gt;&gt; f = throwM e
--   </pre>
throwM :: (MonadThrow m, Exception e) => e -> m a

-- | A class for monads which allow exceptions to be caught, in particular
--   exceptions which were thrown by <a>throwM</a>.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   catch (throwM e) f = f e
--   </pre>
--   
--   Note that the ability to catch an exception does <i>not</i> guarantee
--   that we can deal with all possible exit points from a computation.
--   Some monads, such as continuation-based stacks, allow for more than
--   just a success/failure strategy, and therefore <tt>catch</tt>
--   <i>cannot</i> be used by those monads to properly implement a function
--   such as <tt>finally</tt>. For more information, see <a>MonadMask</a>.
class MonadThrow m => MonadCatch (m :: Type -> Type)

-- | Provide a handler for exceptions thrown during execution of the first
--   action. Note that type of the type of the argument to the handler will
--   constrain which exceptions are caught. See <a>Control.Exception</a>'s
--   <a>catch</a>.
catch :: (MonadCatch m, Exception e) => m a -> (e -> m a) -> m a

-- | A class for monads which provide for the ability to account for all
--   possible exit points from a computation, and to mask asynchronous
--   exceptions. Continuation-based monads are invalid instances of this
--   class.
--   
--   Instances should ensure that, in the following code:
--   
--   <pre>
--   fg = f `finally` g
--   </pre>
--   
--   The action <tt>g</tt> is called regardless of what occurs within
--   <tt>f</tt>, including async exceptions. Some monads allow <tt>f</tt>
--   to abort the computation via other effects than throwing an exception.
--   For simplicity, we will consider aborting and throwing an exception to
--   be two forms of "throwing an error".
--   
--   If <tt>f</tt> and <tt>g</tt> both throw an error, the error thrown by
--   <tt>fg</tt> depends on which errors we're talking about. In a monad
--   transformer stack, the deeper layers override the effects of the inner
--   layers; for example, <tt>ExceptT e1 (Except e2) a</tt> represents a
--   value of type <tt>Either e2 (Either e1 a)</tt>, so throwing both an
--   <tt>e1</tt> and an <tt>e2</tt> will result in <tt>Left e2</tt>. If
--   <tt>f</tt> and <tt>g</tt> both throw an error from the same layer,
--   instances should ensure that the error from <tt>g</tt> wins.
--   
--   Effects other than throwing an error are also overriden by the deeper
--   layers. For example, <tt>StateT s Maybe a</tt> represents a value of
--   type <tt>s -&gt; Maybe (a, s)</tt>, so if an error thrown from
--   <tt>f</tt> causes this function to return <tt>Nothing</tt>, any
--   changes to the state which <tt>f</tt> also performed will be erased.
--   As a result, <tt>g</tt> will see the state as it was before
--   <tt>f</tt>. Once <tt>g</tt> completes, <tt>f</tt>'s error will be
--   rethrown, so <tt>g</tt>' state changes will be erased as well. This is
--   the normal interaction between effects in a monad transformer stack.
--   
--   By contrast, <a>lifted-base</a>'s version of <a>finally</a> always
--   discards all of <tt>g</tt>'s non-IO effects, and <tt>g</tt> never sees
--   any of <tt>f</tt>'s non-IO effects, regardless of the layer ordering
--   and regardless of whether <tt>f</tt> throws an error. This is not the
--   result of interacting effects, but a consequence of
--   <tt>MonadBaseControl</tt>'s approach.
class MonadCatch m => MonadMask (m :: Type -> Type)

-- | Runs an action with asynchronous exceptions disabled. The action is
--   provided a method for restoring the async. environment to what it was
--   at the <a>mask</a> call. See <a>Control.Exception</a>'s <a>mask</a>.
mask :: MonadMask m => ((forall a. () => m a -> m a) -> m b) -> m b

-- | Like <a>mask</a>, but the masked computation is not interruptible (see
--   <a>Control.Exception</a>'s <a>uninterruptibleMask</a>. WARNING: Only
--   use if you need to mask exceptions around an interruptible operation
--   AND you can guarantee the interruptible operation will only block for
--   a short period of time. Otherwise you render the program/thread
--   unresponsive and/or unkillable.
uninterruptibleMask :: MonadMask m => ((forall a. () => m a -> m a) -> m b) -> m b

-- | A generalized version of <a>bracket</a> which uses <a>ExitCase</a> to
--   distinguish the different exit cases, and returns the values of both
--   the <tt>use</tt> and <tt>release</tt> actions. In practice, this extra
--   information is rarely needed, so it is often more convenient to use
--   one of the simpler functions which are defined in terms of this one,
--   such as <a>bracket</a>, <a>finally</a>, <a>onError</a>, and
--   <a>bracketOnError</a>.
--   
--   This function exists because in order to thread their effects through
--   the execution of <a>bracket</a>, monad transformers need values to be
--   threaded from <tt>use</tt> to <tt>release</tt> and from
--   <tt>release</tt> to the output value.
--   
--   <i>NOTE</i> This method was added in version 0.9.0 of this library.
--   Previously, implementation of functions like <a>bracket</a> and
--   <a>finally</a> in this module were based on the <a>mask</a> and
--   <a>uninterruptibleMask</a> functions only, disallowing some classes of
--   tranformers from having <tt>MonadMask</tt> instances (notably
--   multi-exit-point transformers like <a>ExceptT</a>). If you are a
--   library author, you'll now need to provide an implementation for this
--   method. The <tt>StateT</tt> implementation demonstrates most of the
--   subtleties:
--   
--   <pre>
--   generalBracket acquire release use = StateT $ s0 -&gt; do
--     ((b, _s2), (c, s3)) &lt;- generalBracket
--       (runStateT acquire s0)
--       ((resource, s1) exitCase -&gt; case exitCase of
--         ExitCaseSuccess (b, s2) -&gt; runStateT (release resource (ExitCaseSuccess b)) s2
--   
--         -- In the two other cases, the base monad overrides <tt>use</tt>'s state
--         -- changes and the state reverts to <tt>s1</tt>.
--         ExitCaseException e     -&gt; runStateT (release resource (ExitCaseException e)) s1
--         ExitCaseAbort           -&gt; runStateT (release resource ExitCaseAbort) s1
--       )
--       ((resource, s1) -&gt; runStateT (use resource) s1)
--     return ((b, c), s3)
--   </pre>
--   
--   The <tt>StateT s m</tt> implementation of <tt>generalBracket</tt>
--   delegates to the <tt>m</tt> implementation of <tt>generalBracket</tt>.
--   The <tt>acquire</tt>, <tt>use</tt>, and <tt>release</tt> arguments
--   given to <tt>StateT</tt>'s implementation produce actions of type
--   <tt>StateT s m a</tt>, <tt>StateT s m b</tt>, and <tt>StateT s m
--   c</tt>. In order to run those actions in the base monad, we need to
--   call <tt>runStateT</tt>, from which we obtain actions of type <tt>m
--   (a, s)</tt>, <tt>m (b, s)</tt>, and <tt>m (c, s)</tt>. Since each
--   action produces the next state, it is important to feed the state
--   produced by the previous action to the next action.
--   
--   In the <a>ExitCaseSuccess</a> case, the state starts at <tt>s0</tt>,
--   flows through <tt>acquire</tt> to become <tt>s1</tt>, flows through
--   <tt>use</tt> to become <tt>s2</tt>, and finally flows through
--   <tt>release</tt> to become <tt>s3</tt>. In the other two cases,
--   <tt>release</tt> does not receive the value <tt>s2</tt>, so its action
--   cannot see the state changes performed by <tt>use</tt>. This is fine,
--   because in those two cases, an error was thrown in the base monad, so
--   as per the usual interaction between effects in a monad transformer
--   stack, those state changes get reverted. So we start from <tt>s1</tt>
--   instead.
--   
--   Finally, the <tt>m</tt> implementation of <tt>generalBracket</tt>
--   returns the pairs <tt>(b, s)</tt> and <tt>(c, s)</tt>. For monad
--   transformers other than <tt>StateT</tt>, this will be some other type
--   representing the effects and values performed and returned by the
--   <tt>use</tt> and <tt>release</tt> actions. The effect part of the
--   <tt>use</tt> result, in this case <tt>_s2</tt>, usually needs to be
--   discarded, since those effects have already been incorporated in the
--   <tt>release</tt> action.
--   
--   The only effect which is intentionally not incorporated in the
--   <tt>release</tt> action is the effect of throwing an error. In that
--   case, the error must be re-thrown. One subtlety which is easy to miss
--   is that in the case in which <tt>use</tt> and <tt>release</tt> both
--   throw an error, the error from <tt>release</tt> should take priority.
--   Here is an implementation for <tt>ExceptT</tt> which demonstrates how
--   to do this.
--   
--   <pre>
--   generalBracket acquire release use = ExceptT $ do
--     (eb, ec) &lt;- generalBracket
--       (runExceptT acquire)
--       (eresource exitCase -&gt; case eresource of
--         Left e -&gt; return (Left e) -- nothing to release, acquire didn't succeed
--         Right resource -&gt; case exitCase of
--           ExitCaseSuccess (Right b) -&gt; runExceptT (release resource (ExitCaseSuccess b))
--           ExitCaseException e       -&gt; runExceptT (release resource (ExitCaseException e))
--           _                         -&gt; runExceptT (release resource ExitCaseAbort))
--       (either (return . Left) (runExceptT . use))
--     return $ do
--       -- The order in which we perform those two <a>Either</a> effects determines
--       -- which error will win if they are both <a>Left</a>s. We want the error from
--       -- <tt>release</tt> to win.
--       c &lt;- ec
--       b &lt;- eb
--       return (b, c)
--   </pre>
generalBracket :: MonadMask m => m a -> (a -> ExitCase b -> m c) -> (a -> m b) -> m (b, c)
class MonadBase b m => MonadBaseControl (b :: Type -> Type) (m :: Type -> Type) | m -> b where {
    type family StM (m :: Type -> Type) a;
}
liftBaseWith :: MonadBaseControl b m => (RunInBase m b -> b a) -> m a
restoreM :: MonadBaseControl b m => StM m a -> m a
class MonadTrans t => MonadTransControl (t :: Type -> Type -> Type -> Type) where {
    type family StT (t :: Type -> Type -> Type -> Type) a;
}
liftWith :: (MonadTransControl t, Monad m) => (Run t -> m a) -> t m a
restoreT :: (MonadTransControl t, Monad m) => m (StT t a) -> t m a

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a monad
--   transformation:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a
class (Applicative b, Applicative m, Monad b, Monad m) => MonadBase (b :: Type -> Type) (m :: Type -> Type) | m -> b
liftBase :: MonadBase b m => b α -> m α
type family StM (m :: Type -> Type) a
type family StT (t :: Type -> Type -> Type -> Type) a
trySome :: forall a. IO a -> IO (Either SomeException a)

-- | Suppress the <a>Left</a> value of an <a>Either</a>
hush :: Either a b -> Maybe b

module HydraAuctionUtils.Parsers.TxIn
parseTxIn :: ReadM TxIn

module HydraAuctionUtils.L1.Runner.Tracer

-- | <tt>FilePath</tt> used to store the running node data.
newtype StateDirectory
MkStateDirectory :: FilePath -> StateDirectory
[$sel:stateDirectory:MkStateDirectory] :: StateDirectory -> FilePath
data HydraAuctionLog
FromHydraAuction :: !String -> HydraAuctionLog

-- | Filter tracer which logs into a `test.log` file within the given
--   <tt>StateDirectory</tt>.
fileTracer :: StateDirectory -> IO (Tracer IO HydraAuctionLog)

-- | Stdout or null tracer depending the given verbosity level.
stdoutOrNullTracer :: Verbosity -> IO (Tracer IO HydraAuctionLog)
showLogsOnFailure :: Show msg => (Tracer IO msg -> IO a) -> IO a
instance Data.Aeson.Types.FromJSON.FromJSON HydraAuctionUtils.L1.Runner.Tracer.HydraAuctionLog
instance Data.Aeson.Types.ToJSON.ToJSON HydraAuctionUtils.L1.Runner.Tracer.HydraAuctionLog
instance GHC.Generics.Generic HydraAuctionUtils.L1.Runner.Tracer.HydraAuctionLog
instance GHC.Show.Show HydraAuctionUtils.L1.Runner.Tracer.HydraAuctionLog
instance GHC.Classes.Eq HydraAuctionUtils.L1.Runner.Tracer.HydraAuctionLog


-- | Orphan instances for Plutus, Hydra and Cardano API
module HydraAuctionUtils.Extras.PlutusOrphans
instance Data.Aeson.Types.ToJSON.ToJSON PlutusLedgerApi.V1.Time.POSIXTime
instance Data.Aeson.Types.ToJSON.ToJSON PlutusLedgerApi.V1.Scripts.ScriptHash
instance Data.Aeson.Types.FromJSON.FromJSON PlutusLedgerApi.V1.Scripts.ScriptHash
instance Data.Aeson.Types.ToJSON.ToJSON PlutusLedgerApi.V1.Credential.Credential
instance Data.Aeson.Types.FromJSON.FromJSON PlutusLedgerApi.V1.Credential.Credential
instance Data.Aeson.Types.ToJSON.ToJSON PlutusLedgerApi.V1.Credential.StakingCredential
instance Data.Aeson.Types.FromJSON.FromJSON PlutusLedgerApi.V1.Credential.StakingCredential
instance Data.Aeson.Types.FromJSON.FromJSON PlutusLedgerApi.V1.Value.AssetClass
instance Data.Aeson.Types.ToJSON.ToJSON PlutusLedgerApi.V1.Value.AssetClass
instance Data.Aeson.Types.FromJSON.FromJSON PlutusLedgerApi.V1.Value.CurrencySymbol
instance Data.Aeson.Types.ToJSON.ToJSON PlutusLedgerApi.V1.Value.CurrencySymbol
instance Data.Aeson.Types.FromJSON.FromJSON PlutusLedgerApi.V1.Value.TokenName
instance Data.Aeson.Types.ToJSON.ToJSON PlutusLedgerApi.V1.Value.TokenName
instance Data.Aeson.Types.FromJSON.FromJSON PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Data.Aeson.Types.ToJSON.ToJSON PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSON PlutusLedgerApi.V1.Tx.TxId
instance Data.Aeson.Types.ToJSON.ToJSON PlutusLedgerApi.V1.Tx.TxId
instance Data.Aeson.Types.FromJSON.FromJSON PlutusLedgerApi.V1.Time.POSIXTime
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.Aeson.Types.FromJSON.FromJSON PlutusLedgerApi.V1.Tx.TxOutRef
instance Data.Aeson.Types.ToJSON.ToJSON PlutusLedgerApi.V1.Tx.TxOutRef


-- | More Extras for Plutus.Extras
module HydraAuctionUtils.Extras.Plutus
validatorAddress :: SerialisedScript -> Address
scriptCurrencySymbol :: SerialisedScript -> CurrencySymbol

module HydraAuctionUtils.PrettyPrinting
prettyPrintUtxo :: UTxO -> IO ()
instance Prettyprinter.Internal.Pretty Cardano.Api.TxIn.TxId
instance Prettyprinter.Internal.Pretty Cardano.Api.TxIn.TxIn
instance Prettyprinter.Internal.Pretty Cardano.Api.Value.AssetId
instance Prettyprinter.Internal.Pretty (Cardano.Api.TxBody.TxOutValue _a)

module HydraAuctionUtils.Server.ClientId
type ClientId = Int
data ClientResponseScope
Broadcast :: ClientResponseScope
PerClient :: ClientId -> ClientResponseScope
clientIsInScope :: ClientId -> ClientResponseScope -> Bool
instance GHC.Show.Show HydraAuctionUtils.Server.ClientId.ClientResponseScope
instance GHC.Classes.Eq HydraAuctionUtils.Server.ClientId.ClientResponseScope

module HydraAuctionUtils.Server.Protocol
class (ToFromJSON (Input protocol), ToFromJSON (Output protocol), Defaults (Input protocol), Defaults (Output protocol), Defaults (OutputKind protocol)) => Protocol protocol where {
    type family Input protocol = input | input -> protocol;
    type family Output protocol = output | output -> protocol;
    type family OutputKind protocol = outputKind | outputKind -> protocol;
}
getOutputKind :: Protocol protocol => Output protocol -> OutputKind protocol
class Protocol (ClientFor handle) => ProtocolClient handle where {
    type family ClientFor handle;
}
sendInputH :: (ProtocolClient handle, MonadIO m) => handle -> Input (ClientFor handle) -> m ()
receiveOutputH :: (ProtocolClient handle, MonadIO m) => handle -> m (Maybe (Output (ClientFor handle)))
class Protocol (ImplementationFor implementation) => ProtocolServerLogic implementation where {
    type family ImplementationFor implementation;
    type family State implementation = state | state -> implementation;
}
initialState :: ProtocolServerLogic implementation => State implementation
implementation :: ProtocolServerLogic implementation => (ClientId, Input (ImplementationFor implementation)) -> StateT (State implementation) m [(ClientResponseScope, Output (ImplementationFor implementation))]

module HydraAuctionUtils.Server.Client
newtype RealProtocolClient protocol
MkRealProtocolClient :: Connection -> RealProtocolClient protocol
[$sel:connection:MkRealProtocolClient] :: RealProtocolClient protocol -> Connection
data FakeProtocolClient implementation
MkFakeProtocolClient :: MVar (FakeProtocolClientState implementation) -> FakeProtocolClient implementation
[$sel:stateVar:MkFakeProtocolClient] :: FakeProtocolClient implementation -> MVar (FakeProtocolClientState implementation)
data FakeProtocolClientState implementation
MkFakeProtocolState :: State implementation -> [Output (ImplementationFor implementation)] -> FakeProtocolClientState implementation
[$sel:currentServerState:MkFakeProtocolState] :: FakeProtocolClientState implementation -> State implementation
[$sel:receivedOutputs:MkFakeProtocolState] :: FakeProtocolClientState implementation -> [Output (ImplementationFor implementation)]
data AwaitedOutput protocol
Any :: AwaitedOutput protocol
SpecificOutput :: Output protocol -> AwaitedOutput protocol
SpecificKind :: OutputKind protocol -> AwaitedOutput protocol
CustomMatcher :: OutputMatcher protocol -> AwaitedOutput protocol
newtype OutputMatcher protocol
OutputMatcher :: (Output protocol -> Bool) -> OutputMatcher protocol
waitForMatchingOutputH :: (ClientFor client ~ protocol, ProtocolClient client, MonadIO m) => client -> AwaitedOutput protocol -> m (Output protocol)
newFakeClient :: ProtocolServerLogic implementation => IO (FakeProtocolClient implementation)
instance HydraAuctionUtils.Server.Protocol.Protocol protocol => GHC.Show.Show (HydraAuctionUtils.Server.Client.AwaitedOutput protocol)
instance HydraAuctionUtils.Server.Protocol.ProtocolServerLogic implementation => HydraAuctionUtils.Server.Protocol.ProtocolClient (HydraAuctionUtils.Server.Client.FakeProtocolClient implementation)
instance HydraAuctionUtils.Server.Protocol.Protocol protocol => HydraAuctionUtils.Server.Protocol.ProtocolClient (HydraAuctionUtils.Server.Client.RealProtocolClient protocol)
instance GHC.Show.Show (HydraAuctionUtils.Server.Client.OutputMatcher x)

module HydraAuctionUtils.Hydra.Interface
getHydraEventKind :: HydraEvent -> HydraEventKind
data HydraEventKind
GetUTxOResponseKind :: HydraEventKind
TxValidKind :: HydraEventKind
TxInvalidKind :: HydraEventKind
InvalidInputKind :: HydraEventKind
PostTxOnChainFailedKind :: HydraEventKind
CommandFailedKind :: HydraEventKind
SnapshotConfirmedKind :: HydraEventKind
CommittedKind :: HydraEventKind
HeadIsInitializingKind :: HydraEventKind
HeadIsOpenKind :: HydraEventKind
HeadIsClosedKind :: HydraEventKind
ReadyToFanoutKind :: HydraEventKind
HeadIsFinalizedKind :: HydraEventKind
HeadIsAbortedKind :: HydraEventKind
GreetingsKind :: HydraEventKind
PeerConnectedKind :: HydraEventKind
PeerDisconnectedKind :: HydraEventKind
HeadIsContestedKind :: HydraEventKind
type HydraEvent = ServerOutput Tx
type HydraCommand = ClientInput Tx
data HydraProtocol
instance GHC.Show.Show HydraAuctionUtils.Hydra.Interface.HydraEventKind
instance GHC.Classes.Eq HydraAuctionUtils.Hydra.Interface.HydraEventKind
instance HydraAuctionUtils.Server.Protocol.Protocol HydraAuctionUtils.Hydra.Interface.HydraProtocol

module HydraAuctionUtils.Server.Websockets
data ServerQueues protocol
MkServerQueues :: TQueue (ClientId, Input protocol) -> TChan (ClientResponseScope, Output protocol) -> ServerQueues protocol

-- | the queue where WS server thread puts client inputs
[$sel:clientInputs:MkServerQueues] :: ServerQueues protocol -> TQueue (ClientId, Input protocol)

-- | the queue where WS server thread gets outputs created by some another
--   thread with internal logic
[$sel:serverOutputs:MkServerQueues] :: ServerQueues protocol -> TChan (ClientResponseScope, Output protocol)
runWebsocketsServer :: forall protocol. Protocol protocol => Int -> ServerQueues protocol -> IO ()

module HydraAuctionUtils.Time
posixTimeToUTC :: POSIXTime -> UTCTime
currentTimeSeconds :: MonadTime timedMonad => timedMonad Integer
currentTimeMilliseconds :: MonadTime timedMonad => timedMonad Integer
currentPlutusPOSIXTime :: MonadTime timedMonad => timedMonad POSIXTime

module HydraAuctionUtils.Tracing

-- | a transformer that provides a contravariant tracer
newtype TracerT t m a
TracerT :: ReaderT (Tracer m t) m a -> TracerT t m a
[$sel:runTracerT:TracerT] :: TracerT t m a -> ReaderT (Tracer m t) m a

-- | run a tracer by first applying a natural transformation to the tracer
runWithTracer :: forall a t m n. (forall b. n b -> m b) -> Tracer n t -> TracerT t m a -> m a

-- | like <a>runWithTracer</a> but using <a>id</a> as the natural
--   transformation
runWithTracer' :: forall a t m. Tracer m t -> TracerT t m a -> m a

-- | ask the Tracer transformer for its Tracer, tthis just wraps the
--   MonadReader instance method
askTracer :: forall t m. Monad m => TracerT t m (Tracer m t)

-- | a monad that one can trace in the typeclass takes as argument the type
--   that serves as the trace and the monad that you can trace in
class MonadTracer t m | m -> t

-- | trace a message in the monad
trace :: MonadTracer t m => t -> m ()
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (HydraAuctionUtils.Tracing.TracerT t m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader (Control.Tracer.Tracer m t) (HydraAuctionUtils.Tracing.TracerT t m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (HydraAuctionUtils.Tracing.TracerT t m)
instance GHC.Base.Monad m => GHC.Base.Monad (HydraAuctionUtils.Tracing.TracerT t m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (HydraAuctionUtils.Tracing.TracerT t m)
instance GHC.Base.Functor m => GHC.Base.Functor (HydraAuctionUtils.Tracing.TracerT t m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (HydraAuctionUtils.Tracing.TracerT t m)
instance Control.Monad.Trans.Class.MonadTrans (HydraAuctionUtils.Tracing.TracerT t)
instance GHC.Base.Monad m => HydraAuctionUtils.Tracing.MonadTracer t (HydraAuctionUtils.Tracing.TracerT t m)

module HydraAuctionUtils.Tx.Build
minLovelace :: Lovelace
tokenToAsset :: TokenName -> AssetName
mintedTokens :: ToScriptData redeemer => PlutusScript -> redeemer -> [(AssetName, Quantity)] -> TxMintValue BuildTx
mkInlineDatum :: ToScriptData datum => datum -> TxOutDatum ctx
mkInlinedDatumScriptWitness :: ToData a => PlutusScript -> a -> BuildTxWith BuildTx (Witness WitCtxTxIn)

module HydraAuctionUtils.Tx.Utxo
txOutIsAdaOnly :: TxOut CtxUTxO -> Bool
filterAdaOnlyUtxo :: UTxO -> UTxO
filterUtxoByCurrencySymbols :: [CurrencySymbol] -> UTxO -> UTxO

-- | Fuel is Utxo mark used by Hydra Node
filterNonFuelUtxo :: UTxO -> UTxO
filterNotAdaOnlyUtxo :: UTxO -> UTxO
extractSingleUtxo :: UTxO -> Maybe UTxO

module HydraAuctionUtils.Types.Natural
data Natural
intToNatural :: Integer -> Maybe Natural
naturalToInt :: Natural -> Integer
toBuiltinBytestring :: Natural -> BuiltinByteString
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni HydraAuctionUtils.Types.Natural.Natural
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni HydraAuctionUtils.Types.Natural.Natural
instance Data.Aeson.Types.FromJSON.FromJSON HydraAuctionUtils.Types.Natural.Natural
instance Data.Aeson.Types.ToJSON.ToJSON HydraAuctionUtils.Types.Natural.Natural
instance PlutusTx.Numeric.MultiplicativeSemigroup HydraAuctionUtils.Types.Natural.Natural
instance PlutusTx.Numeric.AdditiveSemigroup HydraAuctionUtils.Types.Natural.Natural
instance PlutusTx.Ord.Ord HydraAuctionUtils.Types.Natural.Natural
instance PlutusTx.Eq.Eq HydraAuctionUtils.Types.Natural.Natural
instance GHC.Classes.Ord HydraAuctionUtils.Types.Natural.Natural
instance GHC.Classes.Eq HydraAuctionUtils.Types.Natural.Natural
instance GHC.Show.Show HydraAuctionUtils.Types.Natural.Natural
instance GHC.Generics.Generic HydraAuctionUtils.Types.Natural.Natural
instance PlutusTx.IsData.Class.UnsafeFromData HydraAuctionUtils.Types.Natural.Natural
instance PlutusTx.IsData.Class.ToData HydraAuctionUtils.Types.Natural.Natural
instance PlutusTx.IsData.Class.FromData HydraAuctionUtils.Types.Natural.Natural

module Paths_hydra_auction
version :: Version
getBinDir :: IO FilePath
getLibDir :: IO FilePath
getDynLibDir :: IO FilePath
getDataDir :: IO FilePath
getLibexecDir :: IO FilePath
getDataFileName :: FilePath -> IO FilePath
getSysconfDir :: IO FilePath

module HydraAuctionUtils.BundledData

-- | Lookup a config file similar reading a file from disk.
readDataFile :: FilePath -> IO ByteString
readHydraNodeProtocolParams :: IO ProtocolParameters
lookupProtocolParamPath :: IO FilePath

module HydraAuctionUtils.Fixture

-- | Enumeration of known actors for which we can get the <a>keysFor</a>
--   and <tt>writeKeysFor</tt>.
data Actor
Alice :: Actor
Bob :: Actor
Carol :: Actor
Dave :: Actor
Eve :: Actor
Frank :: Actor
Grace :: Actor
Hans :: Actor
Oscar :: Actor
Patricia :: Actor
Rupert :: Actor
Faucet :: Actor
data ActorKind
RegularActor :: ActorKind
HydraNodeActor :: ActorKind
FaucetActor :: ActorKind
actorName :: Actor -> String

-- | Get the "well-known" keys for given actor. FIXME: cache this
keysFor :: Actor -> IO (VerificationKey PaymentKey, SigningKey PaymentKey)
hydraKeysFor :: Actor -> IO (VerificationKey HydraKey, SigningKey HydraKey)
actorsByKind :: Map ActorKind [Actor]
partyFor :: Actor -> IO Party
allActors :: [Actor]
actorFromPkh :: PubKeyHash -> IO Actor
actorFromSk :: SigningKey PaymentKey -> IO (Maybe Actor)
getActorPubKeyHash :: Actor -> IO PubKeyHash
getActorsPubKeyHash :: [Actor] -> IO [PubKeyHash]
getActorKind :: Actor -> ActorKind
instance GHC.Generics.Generic HydraAuctionUtils.Fixture.Actor
instance GHC.Enum.Bounded HydraAuctionUtils.Fixture.Actor
instance GHC.Enum.Enum HydraAuctionUtils.Fixture.Actor
instance GHC.Classes.Ord HydraAuctionUtils.Fixture.Actor
instance GHC.Show.Show HydraAuctionUtils.Fixture.Actor
instance GHC.Classes.Eq HydraAuctionUtils.Fixture.Actor
instance GHC.Enum.Bounded HydraAuctionUtils.Fixture.ActorKind
instance GHC.Enum.Enum HydraAuctionUtils.Fixture.ActorKind
instance GHC.Classes.Ord HydraAuctionUtils.Fixture.ActorKind
instance GHC.Classes.Eq HydraAuctionUtils.Fixture.ActorKind
instance GHC.Show.Show HydraAuctionUtils.Fixture.ActorKind
instance GHC.Classes.Eq (Cardano.Api.Keys.Class.SigningKey Cardano.Api.Keys.Shelley.PaymentKey)
instance Data.Aeson.Types.FromJSON.FromJSON HydraAuctionUtils.Fixture.Actor
instance Data.Aeson.Types.ToJSON.ToJSON HydraAuctionUtils.Fixture.Actor

module HydraAuctionUtils.Parsers
parseActor :: ReadM Actor
parseAda :: ReadM Lovelace
parseAdaAsNatural :: ReadM Natural
parseMarked :: ReadM Marked
parseNetworkMagic :: ReadM NetworkMagic
parseHost :: Maybe Int -> ReadM Host
cardanoRunningNodeParser :: Parser RunningNode
execParserForCliArgs :: forall x. Parser x -> IO x

module HydraAuctionUtils.Monads
data UtxoQuery
ByAddress :: Address ShelleyAddr -> UtxoQuery
ByTxIns :: [TxIn] -> UtxoQuery
class Monad m => MonadTrace m where {
    type family TracerMessage m;
}
stringToMessage :: MonadTrace m => String -> TracerMessage m
traceMessage :: MonadTrace m => TracerMessage m -> m ()
class Monad m => MonadSubmitTx m
submitTx :: MonadSubmitTx m => Tx -> m (Either SubmitingError ())
awaitTx :: MonadSubmitTx m => Tx -> m ()
class Monad m => MonadQueryUtxo m
queryUtxo :: MonadQueryUtxo m => UtxoQuery -> m UTxO
class Monad m => MonadNetworkId m
askNetworkId :: MonadNetworkId m => m NetworkId
class Monad m => MonadBlockchainParams m
queryBlockchainParams :: MonadBlockchainParams m => m BlockchainParams
queryCurrentSlot :: MonadBlockchainParams m => m SlotNo
convertValidityBound :: MonadBlockchainParams m => Interval POSIXTime -> m (TxValidityLowerBound, TxValidityUpperBound)
data BlockchainParams
MkBlockchainParams :: ProtocolParameters -> SystemStart -> EraHistory CardanoMode -> Set PoolId -> BlockchainParams
[$sel:protocolParameters:MkBlockchainParams] :: BlockchainParams -> ProtocolParameters
[$sel:systemStart:MkBlockchainParams] :: BlockchainParams -> SystemStart
[$sel:eraHistory:MkBlockchainParams] :: BlockchainParams -> EraHistory CardanoMode
[$sel:stakePools:MkBlockchainParams] :: BlockchainParams -> Set PoolId
class (MonadQueryUtxo m, MonadNetworkId m, MonadSubmitTx m, MonadBlockchainParams m) => MonadCardanoClient m
logMsg :: forall m. MonadTrace m => String -> m ()
submitAndAwaitTx :: (MonadSubmitTx m, MonadTrace m) => Tx -> m (Either SubmitingError ())
fromPlutusAddressInMonad :: MonadNetworkId m => Address -> m AddressInEra
addressAndKeysForActor :: (MonadNetworkId m, MonadIO m) => Actor -> m (Address ShelleyAddr, VerificationKey PaymentKey, SigningKey PaymentKey)
toSlotNo :: MonadBlockchainParams m => POSIXTime -> m SlotNo
waitUntil :: (MonadIO m, MonadBlockchainParams m) => POSIXTime -> m ()
waitUntilSlot :: (MonadIO m, MonadBlockchainParams m) => SlotNo -> m ()
instance (HydraAuctionUtils.Monads.MonadQueryUtxo m, HydraAuctionUtils.Monads.MonadNetworkId m, HydraAuctionUtils.Monads.MonadSubmitTx m, HydraAuctionUtils.Monads.MonadBlockchainParams m) => HydraAuctionUtils.Monads.MonadCardanoClient m
instance (HydraAuctionUtils.Monads.MonadBlockchainParams m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => HydraAuctionUtils.Monads.MonadBlockchainParams (t m)
instance (HydraAuctionUtils.Monads.MonadSubmitTx m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => HydraAuctionUtils.Monads.MonadSubmitTx (t m)
instance (HydraAuctionUtils.Monads.MonadTrace m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => HydraAuctionUtils.Monads.MonadTrace (t m)
instance (HydraAuctionUtils.Monads.MonadNetworkId m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => HydraAuctionUtils.Monads.MonadNetworkId (t m)
instance (HydraAuctionUtils.Monads.MonadQueryUtxo m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => HydraAuctionUtils.Monads.MonadQueryUtxo (t m)

module HydraAuctionUtils.Tx.AutoCreateTx
data AutoCreateParams
AutoCreateParams :: [(SigningKey PaymentKey, UTxO)] -> [SigningKey PaymentKey] -> UTxO -> Maybe TxIn -> [(BuildTxWith BuildTx (Witness WitCtxTxIn), UTxO)] -> [TxOut CtxTx] -> TxMintValue BuildTx -> Address ShelleyAddr -> Interval POSIXTime -> AutoCreateParams
[$sel:signedUtxos:AutoCreateParams] :: AutoCreateParams -> [(SigningKey PaymentKey, UTxO)]

-- | List of keys that will sign the tx
[$sel:additionalSigners:AutoCreateParams] :: AutoCreateParams -> [SigningKey PaymentKey]

-- | Utxo which TxIns will be used as reference inputs
[$sel:referenceUtxo:AutoCreateParams] :: AutoCreateParams -> UTxO

-- | Nothing means collateral will be chosen automatically from given UTxOs
[$sel:collateral:AutoCreateParams] :: AutoCreateParams -> Maybe TxIn
[$sel:witnessedUtxos:AutoCreateParams] :: AutoCreateParams -> [(BuildTxWith BuildTx (Witness WitCtxTxIn), UTxO)]
[$sel:outs:AutoCreateParams] :: AutoCreateParams -> [TxOut CtxTx]
[$sel:toMint:AutoCreateParams] :: AutoCreateParams -> TxMintValue BuildTx
[$sel:changeAddress:AutoCreateParams] :: AutoCreateParams -> Address ShelleyAddr
[$sel:validityBound:AutoCreateParams] :: AutoCreateParams -> Interval POSIXTime
autoCreateTx :: (MonadIO m, MonadFail m, MonadBlockchainParams m) => AutoCreateParams -> m Tx
makeSignedTransactionWithKeys :: [SigningKey PaymentKey] -> TxBody -> Tx
callBodyAutoBalance :: MonadBlockchainParams m => UTxO -> TxBodyContent BuildTx -> Address ShelleyAddr -> m (Either TxBodyErrorAutoBalance TxBody)
autoSubmitAndAwaitTx :: (MonadIO m, MonadTrace m, MonadFail m, MonadBlockchainParams m, MonadSubmitTx m) => AutoCreateParams -> m Tx

module HydraAuctionUtils.Monads.Actors
class Monad m => MonadHasActor m
askActor :: MonadHasActor m => m Actor
newtype WithActorT m a
MkWithActorT :: ReaderT Actor m a -> WithActorT m a
withActor :: forall m x. Monad m => Actor -> WithActorT m x -> m x
addressAndKeys :: (MonadHasActor m, MonadNetworkId m, MonadIO m) => m (Address ShelleyAddr, VerificationKey PaymentKey, SigningKey PaymentKey)
actorTipUtxo :: (MonadHasActor m, MonadQueryUtxo m, MonadNetworkId m, MonadIO m) => m UTxO
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (HydraAuctionUtils.Monads.Actors.WithActorT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (HydraAuctionUtils.Monads.Actors.WithActorT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (HydraAuctionUtils.Monads.Actors.WithActorT m)
instance Control.Monad.Trans.Control.MonadTransControl HydraAuctionUtils.Monads.Actors.WithActorT
instance Control.Monad.Trans.Class.MonadTrans HydraAuctionUtils.Monads.Actors.WithActorT
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader HydraAuctionUtils.Fixture.Actor (HydraAuctionUtils.Monads.Actors.WithActorT m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (HydraAuctionUtils.Monads.Actors.WithActorT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (HydraAuctionUtils.Monads.Actors.WithActorT m)
instance GHC.Base.Monad m => GHC.Base.Monad (HydraAuctionUtils.Monads.Actors.WithActorT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (HydraAuctionUtils.Monads.Actors.WithActorT m)
instance GHC.Base.Functor m => GHC.Base.Functor (HydraAuctionUtils.Monads.Actors.WithActorT m)
instance (HydraAuctionUtils.Monads.Actors.MonadHasActor m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => HydraAuctionUtils.Monads.Actors.MonadHasActor (t m)
instance GHC.Base.Monad m => HydraAuctionUtils.Monads.Actors.MonadHasActor (HydraAuctionUtils.Monads.Actors.WithActorT m)

module HydraAuctionUtils.Tx.Common
transferAda :: forall m. (MonadFail m, MonadTrace m, MonadHasActor m, MonadCardanoClient m, MonadIO m) => Actor -> Marked -> Lovelace -> m Tx
selectAdaUtxo :: forall m. (MonadHasActor m, MonadCardanoClient m, MonadIO m) => Lovelace -> m (Maybe UTxO)

module HydraAuctionUtils.Hydra.Monad
newtype ViaMonadHydra m a
MkViaMonadHydra :: m a -> ViaMonadHydra m a
class Monad m => MonadHydra m
sendCommand :: MonadHydra m => HydraCommand -> m ()
waitForHydraEvent' :: MonadHydra m => Natural -> AwaitedHydraEvent -> m (Maybe HydraEvent)
type AwaitedHydraEvent = AwaitedOutput HydraProtocol
waitForHydraEvent :: MonadHydra m => AwaitedHydraEvent -> m (Maybe HydraEvent)
sendCommandAndWaitFor :: MonadHydra m => AwaitedHydraEvent -> HydraCommand -> m (Maybe HydraEvent)
instance HydraAuctionUtils.Hydra.Monad.MonadHydra m => HydraAuctionUtils.Hydra.Monad.MonadHydra (HydraAuctionUtils.Hydra.Monad.ViaMonadHydra m)
instance GHC.Base.Monad m => GHC.Base.Monad (HydraAuctionUtils.Hydra.Monad.ViaMonadHydra m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (HydraAuctionUtils.Hydra.Monad.ViaMonadHydra m)
instance GHC.Base.Functor m => GHC.Base.Functor (HydraAuctionUtils.Hydra.Monad.ViaMonadHydra m)
instance (GHC.Base.Monad m, HydraAuctionUtils.Hydra.Monad.MonadHydra m) => HydraAuctionUtils.Monads.MonadSubmitTx (HydraAuctionUtils.Hydra.Monad.ViaMonadHydra m)
instance (GHC.Base.Monad m, HydraAuctionUtils.Hydra.Monad.MonadHydra m) => HydraAuctionUtils.Monads.MonadQueryUtxo (HydraAuctionUtils.Hydra.Monad.ViaMonadHydra m)
instance HydraAuctionUtils.Hydra.Monad.MonadHydra m => HydraAuctionUtils.Hydra.Monad.MonadHydra (Control.Monad.Trans.State.Lazy.StateT s m)

module HydraAuctionUtils.L1.Runner
data HydraAuctionLog
FromHydraAuction :: !String -> HydraAuctionLog
data EndToEndLog
FromCardanoNode :: NodeLog -> EndToEndLog
FromFaucet :: FaucetLog -> EndToEndLog
data NodeLog
MsgNodeCmdSpec :: Text -> NodeLog
MsgCLI :: [Text] -> NodeLog
MsgCLIStatus :: Text -> Text -> NodeLog
MsgCLIRetry :: Text -> NodeLog
MsgCLIRetryResult :: Text -> Int -> NodeLog
MsgNodeStarting :: FilePath -> NodeLog
[$sel:stateDirectory:MsgNodeCmdSpec] :: NodeLog -> FilePath
MsgSocketIsReady :: FilePath -> NodeLog
MsgSynchronizing :: Centi -> NodeLog
[$sel:percentDone:MsgNodeCmdSpec] :: NodeLog -> Centi
MsgNodeIsReady :: NodeLog

-- | HydraAuction specific L1 computation executor.
data L1Runner a
executeL1Runner :: ExecutionContext -> L1Runner a -> IO a
executeL1RunnerWithNodeAs :: forall x. RunningNode -> Actor -> WithActorT L1Runner x -> IO x
executeL1RunnerWithNode :: forall x. RunningNode -> L1Runner x -> IO x

-- | Executes a test runner using a temporary directory as the
--   <tt>StateDirectory</tt>.
executeTestL1Runner :: L1Runner () -> IO ()
dockerNode :: RunningNode

-- | <tt>FilePath</tt> used to store the running node data.
newtype StateDirectory
MkStateDirectory :: FilePath -> StateDirectory
[$sel:stateDirectory:MkStateDirectory] :: StateDirectory -> FilePath

-- | Execution context holding the current tracer, as well as the running
--   node.
data ExecutionContext
MkExecutionContext :: Tracer IO HydraAuctionLog -> RunningNode -> ExecutionContext
[$sel:tracer:MkExecutionContext] :: ExecutionContext -> Tracer IO HydraAuctionLog
[$sel:node:MkExecutionContext] :: ExecutionContext -> RunningNode
withActor :: forall m x. Monad m => Actor -> WithActorT m x -> m x

-- | Filter tracer which logs into a `test.log` file within the given
--   <tt>StateDirectory</tt>.
fileTracer :: StateDirectory -> IO (Tracer IO HydraAuctionLog)
toSlotNo :: MonadBlockchainParams m => POSIXTime -> m SlotNo

-- | Initiates the actor's wallet using the prescribed amount of faucet
--   <tt>Lovelace</tt>.
initWallet :: forall m. (MonadIO m, MonadFail m, MonadTrace m, MonadCardanoClient m) => Lovelace -> Actor -> m ()

-- | Stdout or null tracer depending the given verbosity level.
stdoutOrNullTracer :: Verbosity -> IO (Tracer IO HydraAuctionLog)
instance Control.Monad.Catch.MonadMask HydraAuctionUtils.L1.Runner.L1Runner
instance Control.Monad.Catch.MonadCatch HydraAuctionUtils.L1.Runner.L1Runner
instance Control.Monad.Catch.MonadThrow HydraAuctionUtils.L1.Runner.L1Runner
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO HydraAuctionUtils.L1.Runner.L1Runner
instance Control.Monad.Base.MonadBase GHC.Types.IO HydraAuctionUtils.L1.Runner.L1Runner
instance Control.Monad.Reader.Class.MonadReader HydraAuctionUtils.L1.Runner.ExecutionContext HydraAuctionUtils.L1.Runner.L1Runner
instance Control.Monad.Fail.MonadFail HydraAuctionUtils.L1.Runner.L1Runner
instance Control.Monad.IO.Class.MonadIO HydraAuctionUtils.L1.Runner.L1Runner
instance GHC.Base.Monad HydraAuctionUtils.L1.Runner.L1Runner
instance GHC.Base.Applicative HydraAuctionUtils.L1.Runner.L1Runner
instance GHC.Base.Functor HydraAuctionUtils.L1.Runner.L1Runner
instance HydraAuctionUtils.Monads.MonadQueryUtxo HydraAuctionUtils.L1.Runner.L1Runner
instance HydraAuctionUtils.Monads.MonadNetworkId HydraAuctionUtils.L1.Runner.L1Runner
instance HydraAuctionUtils.Monads.MonadBlockchainParams HydraAuctionUtils.L1.Runner.L1Runner
instance HydraAuctionUtils.Monads.MonadSubmitTx HydraAuctionUtils.L1.Runner.L1Runner
instance HydraAuctionUtils.Monads.MonadTrace HydraAuctionUtils.L1.Runner.L1Runner

module HydraAuctionUtils.Hydra.Runner
newtype HydraRunner a
MkHydraRunner :: ReaderT HydraExecutionContext IO a -> HydraRunner a
[$sel:unHydraRunner:MkHydraRunner] :: HydraRunner a -> ReaderT HydraExecutionContext IO a
type HydraClient = RealProtocolClient HydraProtocol
data HydraExecutionContext
MkHydraExecutionContext :: HydraClient -> Tracer IO HydraRunnerLog -> ExecutionContext -> Actor -> HydraExecutionContext
[$sel:node:MkHydraExecutionContext] :: HydraExecutionContext -> HydraClient
[$sel:tracer:MkHydraExecutionContext] :: HydraExecutionContext -> Tracer IO HydraRunnerLog
[$sel:l1Context:MkHydraExecutionContext] :: HydraExecutionContext -> ExecutionContext
[$sel:actor:MkHydraExecutionContext] :: HydraExecutionContext -> Actor
executeHydraRunnerFakingParams :: HydraClient -> HydraRunner a -> WithActorT L1Runner a
executeHydraRunner :: HydraExecutionContext -> HydraRunner a -> IO a
runL1RunnerInComposite :: forall a. WithActorT L1Runner a -> HydraRunner a
instance GHC.Show.Show HydraAuctionUtils.Hydra.Runner.HydraRunnerLog
instance HydraAuctionUtils.Monads.MonadQueryUtxo HydraAuctionUtils.Hydra.Runner.HydraRunner
instance HydraAuctionUtils.Monads.MonadSubmitTx HydraAuctionUtils.Hydra.Runner.HydraRunner
instance Control.Monad.Catch.MonadMask HydraAuctionUtils.Hydra.Runner.HydraRunner
instance Control.Monad.Catch.MonadCatch HydraAuctionUtils.Hydra.Runner.HydraRunner
instance Control.Monad.Catch.MonadThrow HydraAuctionUtils.Hydra.Runner.HydraRunner
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO HydraAuctionUtils.Hydra.Runner.HydraRunner
instance Control.Monad.Base.MonadBase GHC.Types.IO HydraAuctionUtils.Hydra.Runner.HydraRunner
instance Control.Monad.Reader.Class.MonadReader HydraAuctionUtils.Hydra.Runner.HydraExecutionContext HydraAuctionUtils.Hydra.Runner.HydraRunner
instance Control.Monad.Fail.MonadFail HydraAuctionUtils.Hydra.Runner.HydraRunner
instance Control.Monad.IO.Class.MonadIO HydraAuctionUtils.Hydra.Runner.HydraRunner
instance GHC.Base.Monad HydraAuctionUtils.Hydra.Runner.HydraRunner
instance GHC.Base.Applicative HydraAuctionUtils.Hydra.Runner.HydraRunner
instance GHC.Base.Functor HydraAuctionUtils.Hydra.Runner.HydraRunner
instance HydraAuctionUtils.Hydra.Monad.MonadHydra HydraAuctionUtils.Hydra.Runner.HydraRunner
instance HydraAuctionUtils.Monads.MonadNetworkId HydraAuctionUtils.Hydra.Runner.HydraRunner
instance HydraAuctionUtils.Monads.MonadTrace HydraAuctionUtils.Hydra.Runner.HydraRunner
instance HydraAuctionUtils.Monads.MonadBlockchainParams HydraAuctionUtils.Hydra.Runner.HydraRunner
instance HydraAuctionUtils.Monads.Actors.MonadHasActor HydraAuctionUtils.Hydra.Runner.HydraRunner

module HydraAuctionUtils.Network
withHydraClient :: Host -> Bool -> (HydraClient -> IO b) -> IO b

module HydraAuctionUtils.Composite.Runner
type CompositeRunner = HydraRunner
runL1RunnerInComposite :: forall a. WithActorT L1Runner a -> HydraRunner a
